{"abstractText": "The system described in [1] was a breakthrough in many respects: it showed that it was possible to implement parallel skeletons [4] a combinators in a functional programming language; it showed how this parallel programming style allowed to write a single source code that produced executables targeted for sequential execution, hence enabling usual debugging techniques, and executables for parallel execution; and it led to the introduc\u2010 tion in OCaml of the ability to marshal functional closures, used later on by a wealth of different applications.", "authors": [{"affiliations": [], "name": "Di Cosmo"}, {"affiliations": [], "name": "Konrad Hinsen"}, {"affiliations": [], "name": "Fr\u00e9d\u00e9ric Gava"}], "id": "SP:2408213c1ea9dde71d420a3b2315d7fbaf4f3d40", "references": [{"authors": ["M. Danelutto", "R. Di Cosmo", "X. Leroy", "S. Pelagatti"], "title": "Parallel Functional Programming with Skeletons: the OCamlP3L experiment.", "venue": "ACM Workshop on ML and its applications. ACM", "year": 1998}, {"authors": ["X. Leroy", "D. Doligez", "A. Frisch", "J. Garrigue", "D. R\u00e9my", "J. Vouillon"], "title": "The OCaml system release 4.09: Documentation and user\u2019s manual", "venue": "Intern report. Inria,", "year": 2019}, {"authors": ["M. Cole"], "title": "Algorithmic skeletons: structured management of parallel computation", "year": 1989}, {"authors": ["J.-F. Abramatic", "R. Di Cosmo", "S. Zacchiroli"], "title": "Building the Universal Archive of Source Code.", "venue": "(Sept", "year": 2018}, {"authors": ["SW EXC.]M. Danelutto"], "title": "Simple Farm test program,\u201d from The OCamlP3l library", "year": 1998}, {"authors": ["SW EXC.]M. Danelutto"], "title": "Pipeline test program,\u201d from The OCamlP3l library", "year": 1998}, {"authors": ["R. Di Cosmo"], "title": "How to use Software Heritage for archiving and referencing your source code: guidelines and walkthrough.", "venue": "HAL preprint \uffffhal-02263344\uffff. Apr", "year": 2019}], "sections": [{"text": "R E S C I E N C E C Reproduction / parallel programming\n[Rp] Reproducing and replicating the OCamlP3l experiment\nDi Cosmo, Roberto1,2, ID and Danelutto, Marco3, ID 1Inria, Paris, France \u2013 2Universit\u00e9 de Paris, Paris, France \u2013 3University of Pisa, Pisa, Italy\nEdited by Konrad Hinsen ID\nReviewed by Fr\u00e9d\u00e9ric Gava ID\nReceived 24 March 2020\nPublished 23 April 2020\nDOI 10.5281/zenodo.4041602\nThis article provides a full report on the effort to reproduce the work described in the article \u201cParallel Functional Programmingwith Skeletons: the OCamlP3L experiment\u201d [1], writ\u2010 ten in 1998. It presented OCamlP3l [2], a parallel programming system written in the OCaml programming language [3].\nThe system described in [1] was a breakthrough in many respects: it showed that it was possible to implement parallel skeletons [4] a combinators in a functional programming language; it showed how this parallel programming style allowed to write a single source code that produced executables targeted for sequential execution, hence enabling usual debugging techniques, and executables for parallel execution; and it led to the introduc\u2010 tion in OCaml of the ability to marshal functional closures, used later on by a wealth of different applications.\nThe article consists of twomainparts, the systemdescription, and the systemevaluation, so replicating the results involves the following:\n1. recover the source code of the OCamlP3l system\n2. make it compile and run on a modern OCaml 4.x system\n3. recover the tests used in the system evaluation\n4. verifywe can get speedup in performance similar to the one reported in the article.\nWhen starting this replication effort, we had the following expectations:\n1. recover the source code should be easy: just look in the paper directory on our machines\n2. compile and run might be difficult: the code was designed 23 years ago for OCaml 1.07\n3. recover tests should be easy: just look in the paper directory on our machines\n4. verify speedup might be challenging: many parameters may have changed in mi\u2010 croprocessors and network.\nThe reality turned out to be surprisingly different. In the following we sum up the steps that we performed to address each of these four challenges, and the final outcome.\nCopyright \u00a9 2020 R. Di Cosmo and M. Danelutto, released under a Creative Commons Attribution 4.0 International license. Correspondence should be addressed to Di Cosmo, Roberto (roberto@dicosmo.org) The authors have declared that no competing interests exist. Code is available at https://archive.softwareheritage.org/swh:1:rev:2db189928c94d62a3b4757b3eec68f0a4d4113f0;origin=https://gitorious.org/ocamlp3l/ocamlp3l_cvs.git/. \u2013 SWH swh:1:rev:2db189928c94d62a3b4757b3eec68f0a4d4113f0;origin=https://gitorious.org/ocamlp3l/ocamlp3l_cvs.git/. Open peer review is available at https://github.com/ReScience/submissions/issues/22.\nReScience C 6.1 (#2) \u2013 Di Cosmo and Danelutto 2020 1\n1 Recovering the source code\nLooking into the original paper directory turned out to be of little help, as there was no trace of the source code or any useful information. So we turned to the paper itself, and found three links to web pages:\n\u2022 www.di.unipi.it/~marcod/ocamlp3l/ocamlp3l.ml, that today returns 404; looking at the archived copies on the archive.org allowed to recover some documentation, but not the source code;\n\u2022 www.di.unipi.it/~susanna/p3l.ml, that is still live, but provides no useful link to the source code\n\u2022 pauillac.inria.fr/ocaml, that is also live, but the only hope to find the source code was the link to the anonymous CVS server which points today to the OCaml GitHub organization, where we found no trace of this 23 years old code.\nSearching the web The links from the original paper being now useless, we resorted to searching the web, and found http://ocamlp3l.inria.fr/. We followed the link http:// ocamlp3l.inria.fr/eng.htm#download to the download page that offered an ftp link, ftp: //ftp.inria.fr/INRIA/caml- light/bazar-ocaml/ocamlp3l/ocamlp3l-2.03.tgz, now dead, and web link, http://ocamlp3l.inria.fr/ocamlp3l-2.03.tgz that was still working. Unfortunately, this is version 2.03 of OCamlP3l, way more evolved, and quite different from the version 0.9 used in the original research article, and there was no trace of the version history, so the quest was far from over.\nSaving version 2.03 Here we decided to make a pause, and properly deposit this ver\u2010 sion 2.03, with extendedmetadata, into Software Heritage [5] via the HAL national open access archive, the result being now availabe as [6].\nBack to searching theweb Moreweb searches brough up a relatedwebpage for a newer system, http://camlp3l.inria.fr/eng.htm touting a link to a git repository on Gitorious, http: //gitorious.org/camlp3l/. Unfortunately, following the link leads to nowhere, as Gitorious has been shutdown in 2015, but luckily Software Heritage has saved the full content of Gitorious, so we could download a a full copy of the git repository, but unfortunately its version history only goes back to 2011, with version 1.03 of CamlP3l, not OCamlP3l, and no trace of earlier versions of the system, so we were seemingly back to square one.\nFinding it on Software Heritage This long journey gave us an idea: what about search\u2010 ing directly in Software Heritage? This turned out to be the lucky strike: a full copy of https://gitorious.org/ocamlp3l/ocamlp3l_cvs.git had been safely archived by Software Heritage in 2015, and we found in it the whole version history starting from 1997. The journey ended successfully, we had found the source code!\n2 Compiling and running\nWe did not know exactly which version of the source code was used in the article, but since the article was published in September 1998, it seemed safe to pick in the version control system a stable version dating from a few months before.\nWe settled for the version of code source available in the directory whose SWH\u2010ID is swh:1:dir:01d2169c88d0783182b1b7facffa522ba09b5957 contained in the revision dated\nReScience C 6.1 (#2) \u2013 Di Cosmo and Danelutto 2020 2\nJune 23rd 1991 with SWH\u2010ID swh:1:rev:2db189928c94d62a3b4757b3eec68f0a4d4113f0.\nThe code contained in this directory seems to be version 1.0 [7] and is classified as fol\u2010 lows by the sloccount utility:\nSLOC Directory SLOC\u2010by\u2010Language (Sorted) 1490 ocamlp3l\u2010vprocess ml=1490 1451 Source ml=1451 1162 Examples ml=1138,perl=13,csh=11 159 ocamlp3l\u2010vthread ml=159 67 Doc ml=67 31 Tools csh=31\nTo our great surprise, and satisfaction, the code compiled with the modern OCaml 4.05 installed on our machines unchanged. The only notable difference is that the modern compiler produces several newwarnings that correspond to better static analysis checks introduced over the past quarter of a century.\nThis is a remarkable achievement, not just for our own code, but for OCaml itself.\n3 Recovering the test suite and replicating speedup figures\nHere too, looking into the original paper directory turned out to be of little help, as there was no trace of the test suite used in the article or any useful information. Web searches were of little interest, as this test suite was used only for the article and not published. A long search through old backups on tape, CR\u2010ROMS and DVDs did not yield anything relevant either. Hence, our reproducibility journey ended here.\nBut we did not want to stop here: having found the original code, we could replicate the speed\u2010up results, using a new test suite. After all, according to the article we wrote over 22 years ago, the original test suite was just producing a computational load to keep the compute nodes busy enough to take advantage of the parallelism.\nAs a first step, we adapted code in the Examples directory, from the SimpleFarm/simple\u2010 farm.ml [8] and the PerfTuning/pipeline.ml [9] files. The result is a simple parametric test code, shown in Figure 1, that allows to test the speedup one can get from the farm parallel skeleton in configurations obtained by varying the number nproc of process\u2010 ing nodes, and the time msecwait elapsed in each sequential computation.\nThe second step was to make the ocamlp3lrun driver command [10], that was using rsh (see these two occurrences) and rcp (see this occurrence) back in 1997 , work with the ssh and scp commands that are mainstream today. A quick hack that works without even touching the code is to create an executable file rsh containing just the two lines:\n#! ssh $*\nand similarly for rcp. Running the parallel test on a set of n different machines is then a simple matter of issueing the commands\nocamlp3lcc -par test-for-speedup.ml ocamlp3lrun test-for-speedup <machine1> <machine2> ... <machinen>\nReScience C 6.1 (#2) \u2013 Di Cosmo and Danelutto 2020 3\nThe third step was to run a parameter sweep experiment on a cluster available at the University of Pisa, and collect the data that was used to produce the new figures that we show in Figure 2.\nThe cluster is configured with 32 nodes each equipped with dual socket Intel(R) Xeon(R) CPU E5\u20102640 v4 2.40GHz. At the time of this experiment 5 nodes where busy or in main\u2010 tainance and therefore our replication experiments were run with parallelism degrees nw \u2208 [1 \u2212 24]. It is worth pointing out that the cluster nodes, differently from the ones used in the original experiments, sport 20 cores with 2\u2010way hyperthreading. Hence, in order to replicate the very same experiments dating back to late \u201990s, we used only one process per node, as if the node had a single processor available. Figure 2a and Figure 2b show the completion times and the relative speedupsmeasured\nReScience C 6.1 (#2) \u2013 Di Cosmo and Danelutto 2020 4\nin three different experiments, processing streams of data items of different lengths. The completion times are very close to the ideal ones, but looking at the speedup fig\u2010 ures we can see that the larger the load the better speedup is achieved. Indeed, the inter\u2010 arrival time of tasks on the stream is negligible with respect to the time spent processing the single task and therefore longer streams help giving more work to each one of the \u201cworkers\u201d in the parallel farm. This, in turn, results in a minor impact of the overheads associated to the set up and orchestration of the nodes that take part in the computation. Figure 2c shows the result of three different runs of the same experiments, executed at three different times of the same day on the cluster. We observe the same completion times, confirming the stability results already achieved at the time OcamlP3L was devel\u2010 oped. Finally, Figure 2d reports the scaled speedup results. For each parallelism degree nw, we used an input streamwhose length was k\u00d7nw. The measured completion times are almost constants and close to the ideal one, which is the sequential time taken to compute a k item stream.\nTo sum up, we could replicate quite faithfully the quality of the results achieved more than 20 years ago. It is worth pointing out that this is a nontrivial achievement, as the architectures used for these experiments today and in the past are completely differ\u2010 ent, both in terms of computation power (processors) and in terms of communication bandwidth and latency (network interface cards). In our opinion, this is clearly due to two distinct and synergic factors:\n\u2022 the clean \u201cfunctional\u201d design and implementation of OcamlP3l, that resisted to language and system development, and\n\u2022 the algorithmic skeleton1 principles which are the base of the overall implemen\u2010 tation of OcamlP3L that naturally implement \u201cportability\u201d across different archi\u2010 tectures, independently of the fact the architectures use different hardware.\n1aka \u201cparallel design patterns\u201d\nReScience C 6.1 (#2) \u2013 Di Cosmo and Danelutto 2020 5\n4 Conclusion\nWe have reported on our experience in reproducing work we have done ourselves on the OCamlP3l experiment over 22 years ago [1]. Contrary to our expectations, the most difficult part has been to recover the source code. For its presevation, we had relied on in\u2010 stitutional repositories first, and freely available collaborative development platforms later, neither of which passed the test of time.\nWe are delighted to report that leveraging the SoftwareHeritage archive [5] we have been able to recover the full history of development of the system, and rebuild it as it likely was at the time the original article had been published. Despite the fact that we did not find the exact test suite used 22 years ago to test the scalability of the system, we have been able to replicate the results on modern hardware.\nAs a byproduct of this work, we have also safely archived in Software Heritage, and de\u2010 scribed in HAL, the stable final release 2.3 of OCamlP3l [6].\nBased on this experience, we strongly suggest to systematically archive and reference research source code following the Software Heritage guidelines [11]."}], "title": "[Rp] Reproducing and replicating the OCamlP3l experiment", "year": 2020}