{"abstractText": "A Josephson junction is a quantum mechanical device composed of two superconduct\u2010 ing electrodes separated by a weak link [1]. For currents lower than a critical value IC , coupled electrons (Cooper pairs) can cross the weak link without a potential difference (dc Josephson effect). When the current is increased above IC , single electrons origi\u2010 nated by the breakup of Cooper pairs begin to traverse the weak link. The potential dif\u2010 ference V between the two superconducting films becomes \u0338= 0 and a state is reached where the junction behaves as a resistance. In modern Josephson junctions the weak link is usually a thin insulating tunnel barrier (SIS junction) [2], a normal metal film (SNS junction) [3] or a physical nanoconstriction (ScS junction) [4, 5]. Josephson junctions have found wide usage in several research fields, for example as buildingblocks forRSFQdigital electronics or quantumcomputers [6], or as radiation detectors and very sensitive magnetometers (SQUIDs) [7, 8, 9]. But the most successful application of Josephson junctions is surely in voltage metrology. A microwave radiation of frequency f can phase lock the junction oscillations, producing the so\u2010called Shapiro\u2010steps, i.e., current steps at the quantized voltages Vn,", "authors": [{"affiliations": [], "name": "Sabino Maggi"}, {"affiliations": [], "name": "Nicolas P. Rougier"}, {"affiliations": [], "name": "Pierre de Buyl"}], "id": "SP:b5e6d11cd46fa18f23313c7efe62afc7c6ed0f7c", "references": [{"authors": ["A. Barone", "G. Patern\u00f2"], "title": "Physics and Applications of the Josephson Effect", "year": 1982}, {"authors": ["M. Gurvitch", "M.A. Washington", "H.A. Huggins"], "title": "High quality refractory Josephson tunnel junctions utilizing thin aluminum layers.", "venue": "Applied Physics Letters", "year": 1983}, {"authors": ["S.P. Benz"], "title": "Superconductor\uffffnormal\uffffsuperconductor junctions for programmable voltage standards.", "venue": "Applied Physics Letters", "year": 1995}, {"authors": ["S.A. Cybart", "E.Y. Cho", "T.J. Wong", "B.H. Wehlin", "M.K. Ma", "C. Huynh", "R.C. Dynes"], "title": "Nano Josephson superconducting tunnel junctions in YBa2Cu3O7\u2013\u03b4 directly patterned with a focused helium ion beam.", "venue": "Nature Nanotechnology", "year": 2015}, {"authors": ["N. De Leo", "M. Fretto", "V. Lacquaniti", "C. Cassiago", "L. D\u2019Ortenzi", "L. Boarino", "S. Maggi"], "title": "Thickness Modulated Niobium Nanoconstrictions by Focused Ion Beam and Anodization.", "venue": "IEEE Transactions on Applied Superconductivity", "year": 2016}, {"authors": ["K. Likharev", "V. Semenov"], "title": "RSFQ logic/memory family: a new Josephson-junction technology for subterahertz-clock-frequency digital systems.", "venue": "IEEE Transactions on Appiled Superconductivity 1.1 (Mar", "year": 1991}, {"authors": ["S. Maggi", "N. De Leo", "V. Lacquaniti", "A. Agostino", "R. Gonnelli", "P. Verhoeve"], "title": "Nb/Al STJ detectors with sub-nA subgap current.", "venue": "Physica C: Superconductivity and its Applications", "year": 2006}, {"authors": ["A.G.P. Troeman", "H. Derking", "B. Borger", "J. Pleikies", "D. Veldhuis", "H. Hilgenkamp"], "title": "NanoSQUIDs Based on Niobium Constrictions.", "venue": "Nano Letters", "year": 2007}, {"authors": ["C. Granata", "A. Vettoliere", "R. Russo", "M. Fretto", "N.D. Leo", "E. Enrico", "V. Lacquaniti"], "title": "Ultra High Sensitive Niobium NanoSQUID by Focused Ion Beam Sculpting.", "venue": "Journal of Superconductivity and Novel Magnetism", "year": 2015}, {"authors": ["R. Kautz", "C. Hamilton", "F. Lloyd"], "title": "Series-array Josephson voltage standards.", "venue": "IEEE Transactions on Magnetics", "year": 1987}, {"authors": ["R. Monaco"], "title": "Enhanced ac Josephson effect.", "venue": "Journal of Applied Physics", "year": 1990}, {"authors": ["D. Andreone", "V. Lacquaniti", "S. Maggi"], "title": "Experiments on Josephson Junctions Driven by a Bi-Harmonic RF Source.", "year": 1991}, {"authors": ["D. Andreone", "V. Lacquaniti", "S. Maggi"], "title": "Numerical and Experimental Results on Josephson Junctions Irradiated by a Biharmonic Drive.", "venue": "Superconducting Devices and Their Applications", "year": 1992}, {"authors": ["S. Maggi"], "title": "Step width enhancement in a pulse\uffffdriven Josephson junction.", "venue": "Journal of Applied Physics 79.10", "year": 1996}, {"authors": ["S. Maggi"], "title": "Enhanced phase locking in a Josephson junction driven by current pulses.", "venue": "Journal of Low Temperature Physics 106.3-4", "year": 1997}, {"authors": ["R.W. Henry", "D.E. Prober"], "title": "Electronic analogs of double\uffffjunction and single\uffffjunction SQUIDs.", "venue": "Review of Scientific Instruments", "year": 1981}, {"authors": ["D.E. McCumber"], "title": "Effect of ac Impedance on dc Voltage\uffffCurrent Characteristics of Superconductor Weak\uffffLink Junctions.", "venue": "Journal of Applied Physics", "year": 1968}, {"authors": ["W.C. Stewart"], "title": "Current\uffffvoltage characteristics of superconducting tunnel junctions.", "venue": "Journal of Applied Physics", "year": 1974}, {"authors": ["D.G. McDonald", "E.G. Johnson", "R.E. Harris"], "title": "Modeling Josephson junctions.", "venue": "Physical Review B", "year": 1976}, {"authors": ["A. Boyanski"], "title": "FPP - A Fortran Preprocessor", "venue": "Tech. rep. Department of Energy,", "year": 1992}, {"authors": ["D.E. Knuth"], "title": "The Future of Tex and METAFONT.", "venue": "TUGboat", "year": 1990}], "sections": [{"text": "R E S C I E N C E C"}, {"heading": "Replication / Physics", "text": "[Rp] Reproduction of Step width enhancement in a pulse-driven Josephson junction\nSabino Maggi1, ID 1National Research Council, Institute of Atmospheric Pollution Research, CNR-IIA, Bari, Italy\nEdited by Nicolas P. Rougier ID\nReviewed by Pierre de Buyl ID\nReceived 01 March 2020\nPublished 29 June 2020\nDOI 10.5281/zenodo.3922195\n1 Introduction\nA Josephson junction is a quantum mechanical device composed of two superconduct\u2010 ing electrodes separated by a weak link [1]. For currents lower than a critical value IC , coupled electrons (Cooper pairs) can cross the weak link without a potential difference (dc Josephson effect). When the current is increased above IC , single electrons origi\u2010 nated by the breakup of Cooper pairs begin to traverse the weak link. The potential dif\u2010 ference V between the two superconducting films becomes \u0338= 0 and a state is reached where the junction behaves as a resistance. In modern Josephson junctions the weak link is usually a thin insulating tunnel barrier (SIS junction) [2], a normal metal film (SNS junction) [3] or a physical nanoconstriction (ScS junction) [4, 5]. Josephson junctions have found wide usage in several research fields, for example as buildingblocks forRSFQdigital electronics or quantumcomputers [6], or as radiation detectors and very sensitive magnetometers (SQUIDs) [7, 8, 9]. But the most successful application of Josephson junctions is surely in voltage metrology. A microwave radiation of frequency f can phase lock the junction oscillations, producing the so\u2010called Shapiro\u2010steps, i.e., current steps at the quantized voltages Vn,\nVn = n h\n2e f, n = 1, 2, ... (1)\nwhereh and e are the Plank constant and electron charge, respectively. The ac Josephson effect is at the basis of the current quantum voltage standard. Besides its practical applications, the Josephson junction is important from a physical point of view because it has been the first device showing a quantummechanical effect on a macroscopic scale. An important research topic at the beginning of the \u201990s was related to finding ways to increase the amplitude of the current steps induced by the microwave radiation (rf\u2010 induced steps). In fact, the stability of the lock between the phase of the junction and the applied microwave radiation \u2013 and therefore its insensitivity to noise events which might switch the junction from one quantized voltage to another, a crucial problem for voltage standard applications \u2013 is strongly dependent on the amplitude of the steps [10]. To increase the amplitude of the current steps, a non\u2010sinusoidal microwave radiation may be used. In 1990 Monaco showed that, in the limit of a voltage\u2010biased Josephson\nCopyright \u00a9 2020 S. Maggi, released under a Creative Commons Attribution 4.0 International license. Correspondence should be addressed to Sabino Maggi (sabino.maggi@cnr.it) The authors have declared that no competing interests exist. Code is available at https://github.com/sabinomaggi/ten-years-challenge-pulsed-drive. \u2013 SWH swh:1:dir:bc7700a81a8fd426d06d89c15c9655998d12c523. Open peer review is available at https://github.com/ReScience/submissions/issues/23.\nReScience C 6.1 (#10) \u2013 Maggi 2020 1\njunction, adding together two phased microwaves of frequency f and 2f produces rf\u2010 induced current steps whose amplitudes are larger than those observed with a sinu\u2010 soidal radiation [11]. Experiments on the so\u2010called \u201cbiharmonic drive\u201d readily confirmed these conclusions, albeit with some limitations due to the fact that the junctions could not realistically be considered as voltage biased [12, 13]. Extending further the idea, Monaco showed that, still in the limit of voltage bias, if the microwave radiation is composed of a train of delta functions, the rf\u2010induced current steps could become as large as the critical current IC . However, a voltage bias configuration does not properly model a real Josephson junc\u2010 tion, which should usually be considered as current biased. Also, a pulse train com\u2010 posed of delta functions is only a theoretical approximation and cannot be reproduced in actual experiments. This led to the idea to investigate what happened to a current\u2010 biased Josephson junction irradiated by a more realistic pulsed microwave signal [14, 15]. The reproduction of this investigation is the object of the present work.\n2 Computational context\nA first attempt to solve this problem was made using an electronic analog simulator of a Josephson junction [16], that could compute the relation between the applied current and the voltage (I \u2212 V characteristic) of a current\u2010biased junction, in the framework of the Stewart\u2010McCumber RSJ junction model [17, 18]. The analog simulator was fast and simple to use, and could produce in just a fewminutes on a Hewlett Packard 7475A2 pen plotter beautiful plots of the I \u2212 V characteristics of the junction as a function of the simulated microwave signal. 1 However, even if the electronic simulation was extremely fast, the analysis of the results required to measure by hand the amplitude of the rf\u2010induced current steps visible on each I \u2212 V characteristic, a tedious and error\u2010prone task. I then decided to develop a Fortran program to solve numerically the nonlinear second\u2010 order differential equation that models the Josephson junction [17, 18]. The idea was to calculate the I \u2212 V characteristics of the junction as a function of the amplitude of the microwave signal, \u03b1rf, for a given set of parameters characterizing the junction and the microwave, considering the three different cases of standard sinusoidal drive, biharmonic drive and pulsed drive. To ease comparison of the results, normalized units were used throughout the calcu\u2010 lations. The normalized junction voltage was \u03b7 and the normalized current \u03b1dc. The main parameters of the simulation were: hysteresis parameter \u03b2, microwave frequency \u2126, amplitude of the microwave signal \u03b1rf, pulse width \u03c1, integration time \u03c4 . For a given set of junction parameters, usually 100 different I \u2212 V characteristics for increasing or decreasing values of \u03b1rf were calculated. The first versions of the Fortran program were compiled under DOS 6.22 with Microsoft Fortran 5.1 and run on what was then a state\u2010of\u2010the\u2010art PC, probably a Compaq Deskpro 486 with a math coprocessor, shared among several users of the lab. The limitations of a PC for such a task soon become evident. A new simulation started automatically each evening and took the entire night to complete. People still using the PC late in the evening often inadvertently stopped the background process or simply shut the machine down without checking if there was another job running. At the end, I could run a full simulation only every two or three days. After a fewweeks of thesemostly unsuccessful attempts, a colleague of another research group proposed me to use four DEC workstations running ULTRIX for my own simula\u2010\n1Unfortunately, after 25 years and two relocations, I could notmanage to find photographs of the simulator nor the original HP 7475A plots.\nReScience C 6.1 (#10) \u2013 Maggi 2020 2\ntions.2 The machines were heavily used by his group during working hours, but sat mostly idle overnight. If I could manage to finish my runs before the start of the new work day, I was allowed to use this idle time for my own simulations. The colleague gave me a quick crash course on Unix and I was ready to go. Porting my Fortran program from Microsoft Fortran 5.1 to ULTRIX was a breeze, and I quickly learnt how to use FTP to transfer the input configuration files and the output data files containing the results of the simulations back and forth from the DEC work\u2010 stations to my Compaq 386 notebook, that was also my desktop computer. Now each day I had four different sets of data files coming from the DEC workstations. Three of them were obtained by irradiating the junction with a pulsed drive with de\u2010 creasing values of \u03c1, while keeping constant \u03b2 and \u2126. The fourth simulation was made by irradiating the junction with a sinusoidal drive, while keeping everything else equal. This last simulation was used as a reference, to compare the results obtained with a standard sinusoidal radiation with those obtained with progressively shorter pulses. Each night I changed the values of \u03b2 or \u2126, to study the effect of these parameters on the behavior of the junction. Again, the real problem was how to analyze all this data. A manual analysis like that needed with the electronic simulator was out of consideration. I decided to try the re\u2010 cently released Microsoft Visual Basic 1.0 for Windows, writing another program that calculated the size of the rf\u2010induced current steps visible on the I \u2212V characteristics of the nightly simulations, as a function of \u03b1rf. The results of months of calculations were summarized in a paper published in the Jour\u2010 nal of Applied Physics [14].\n3 Digging into code\nI like organisation, and I try keep all my past projects on my main workstation. Thus, finding the original source and data files of this project was only a question of locating thedirectorywhere the projectwas stored. Problems started to arisewhen I looked at the different files. The whole project was scattered into several directories, each containing many files with widely different names and dates. At first, trying to find an order in that chaos seemed impossible. Normally I would have found all information needed inmany notebooks full of detailed handwritten notes. Unfortunately, a couple of years ago most of my work notebooks were damaged by a water leak in the basement, and could not be recovered. The only option left was to check the files one by one. After a thorough inspection of thewhole project I recalled that: (1)myfirst attemptswith the numerical simulations tried to use the more accurate McDonald\u2010Johnson junction model [19], I later switched to the simplified Stewart\u2010McCumber RSJ model because it wasmuch faster and efficient in calculating the junction behavior [17, 18]; (2) file names attempted to reflect what the programs actually did, at least within the limits of DOS 8+3 naming scheme: in the same directory I could have a file ending with a \u201c\u201d that provided a textual output and another file ending with a \u201cg\u201d that gave a graphical output, and they differed only for a couple of DEFINESs that controlled the conditional compilation of the proper sections of the source code. This multiplication of files might seem senseless today, when comfortable graphical in\u2010 terfaces, ultra\u2010fast text editors with support of regular expressions and version control tools allow to change a large set of files in just a few seconds, but at that time it was prob\u2010 ably the fastest, albeit very inefficient, way of working with source code; (3) the header of all source files contained detailed notes about the type of program, the compiler, the type of output and the dates of first and last revision of the source file, considerably\n2The now defunct Digital Equipment Corporation (DEC) was one of the leading computer companies of the time and ULTRIX is the name of its Unix operating system.\nReScience C 6.1 (#10) \u2013 Maggi 2020 3\neasing the analysis of the different versions of the Fortran programs (Fig. 1); (4) the ini\u2010 tial versions of the Fortran programs weremonolithic, a single source file contained the whole code, that consisted in about 1.000 lines of Fortran. Only at a later time, better computing practices taught me to divide the monolithic code into multiple source files, compiled and linked together with a Makefile. Another invaluable tool to analyze the different versions of the source files wasMeld, an open source application available for allmajor operating systems that canperforma two\u2010 and even a three\u2010way comparison of files and directories. Using Meld I quickly realized that the twomost interesting sourcefilesweremcphase.for andmcp-work.for, both located in the mccumber/ directory (Fig. S1). The first program, mcphase.for, simulated the behavior of the junction for a single value of \u03b1rf read from the input configuration file mc-iv.dat, and saved the I \u2212 V characteristic of the junction and its phase portrait (i.e., the relation between the phase and its time derivative, the latter being proportional to the junction voltage V ) in the output file mc-iv.out. Multiple calculations with several different value of \u03b1rf were performed by using a DOS batch file that basically choose one by one the configuration files containing the desired values of \u03b1rf, renamed them to iv.dat, run the compiled executable mcphase.exe and at the end renamed the file containing the results, mc-iv.out, using a consistent naming scheme. I don\u2019t recall why I choose this approach, but it was clearly very ineffi\u2010 cient, as it required to prepare each day a long series of configuration files that differed only by the value of \u03b1rf, and to update accordingly the DOS batch file that controlled the night calculations (Fig. S2). The second program, mcp-work.for was an improved version that could cycle across a set of several values of \u03b1rf, producing a different output file for each value of \u03b1rf. To simplify the later automatic analysis, it left out the phase portrait. Clearly this was the program ported to the DECworkstations. Unfortunately, I could not find the actual source file used on these machines, perhaps because I worked directly on the workstations and never thought to copy back these files to my PCs. But Fortran is a very stable language and making mcp-work.for work on a modern machine was very easy.\nReScience C 6.1 (#10) \u2013 Maggi 2020 4\nAs for the Microsoft Visual Basic 1.0 code, I found only two versions of the programs and the differences between them were minimal. Since both programs gave exactly the same results, I decided to stick with the version that had a still working precompiled binary file.\n4 Porting Microsoft Fortran to modern Unix\nPortingmcp-work.for to the XXI century so that it could be compiledwith themodern open source and multiplatform gfortran Fortran compiler was very easy, thanks to the stability of the language across different versions and platforms. Only a few minor tweaks to the source code were needed. All work has been done onmacOS, which is essentially BSD Unix with a more appealing graphical interface, but it can be easily repeated on any modern Unix\u2010like operating system such as Linux, and probably even on Windows, with the support of either the Windows Subsystem for Linux (forWindows 10) or of Cygwin (for earlier versions of the operating system).\n4.1 Preprocessor directives For reasons that go beyondmyunderstandingMicrosoft Fortran 5.1 did not use standard preprocessor directives, such as those supported by cpp or fpp, [20] but used a a slightly different proprietary syntax (Fig. S3). To support cpp, all was needed was to comment out all the $DEFINE directives in the header section of mcp-work.for and to replace the Microsoft Fortran 5.1 DEFINE blocks with standard cpp blocks throughout the code (Fig. S3). The right directives are chosen now at compile\u2010time. For example, the following com\u2010 mand 3\n$ gfortran -cpp -Dtextout -Dsingle -o mcp-work mcp-work.for\nruns the cpp preprocessor before the gfortran compiler, selecting only the sections of code that produce a textual output (-Dtextout) and simulate the junction behavior with the sinusoidal drive (-Dsingle).\n4.2 Filenames Compilers based on Fortran 77, such as Microsoft Fortran 5.1, did not support dynamic memory allocation at runtime and required programmers to use fixed\u2010length arrays and strings. Strings were used rather sparingly in Fortran code, so that was not a big deal. With an exception. My code defined the basename of all files as the 50\u2010byte long charac\u2010 ter variable filename, attaching a proper extension to the input configuration file that contained the simulation parameters and to the output data files with the results of the calculations. Under DOS that was not a problem, as DOS truncates file names to only 8 characters plus 3 characters for the extension, and excess characters were simply ignored. But under Unix file names have no practical limitations,4 and having all these 50 character\u2010 long filenames, mostly composed by blank characters, was ugly and complicated file management, in particular when using the command line interface. The solution was simple, as Fortran now has the TRIM function, that removes all trailing blanks from a string. Whenever a file is opened for reading or for writing, TRIM() is applied on\u2010the\u2010fly to the filename variable,\n3The $ symbol prepended to this and to all following terminal commands represents the prompt of the command interpreter and is not part of the command.\n4Unix allows 255 characters for the filename and 4096 characters for the path.\nReScience C 6.1 (#10) \u2013 Maggi 2020 5\nOPEN (UNIT = 10, FILE = TRIM(filename)//\u2019.dat\u2019, STATUS = \u2019OLD\u2019)\nthus removing all extra blanks from the name of the file.\n4.3 Edit descriptors Microsoft Fortran 5.1 used the backslash (\\) edit descriptor to prevent the addition of a line break at the end of a WRITE instruction. Modern Fortran compilers do not sup\u2010 port this non\u2010standard edit descriptor and return an error. This problem is avoided by removing the backslash from all WRITE instructions that include it.\n4.4 Date and time Microsoft Fortran 5.1 had two separate intrinsic subroutines to return the current date and time. In particular, CALL GETDAT(iyr, imon, iday), saved the date in the two\u2010byte integer variables iyr, imon and iday, while CALL GETTIM(ihr, imin, imin, i100th) did the same for the current time, saving the return values in the in\u2010 teger variables ihr, imin, imin and i100th. The meaning of each returned variable should be self\u2010explanatory. Modern Fortran supports the single subroutineCALL DATE_AND_TIME(DATE, TIME, ZONE, VALUES), where all arguments are optional and canbe specifiedby their dummy names (i.e., how Fortran calls the keyword arguments of a function call). In particular, DATE, TIME and ZONE are character variables, while VALUES is a one\u2010dimensional ar\u2010 ray of 8 integers, where VALUES(1:3) corresponds to the year, month and day of the month, VALUES(4) is the time difference (in minutes) with UTC, and VALUES(5:8) are the hour, minute, second and milliseconds, respectively. To minimize changes to the original source code, the calls to the GETDAT and GETTIM subroutines, were translated to a single call to DATE_AND_TIME, assigning the elements of the returned array of VALUES to integer variables named as in the original code (Fig. S4).\n4.5 Compilation with gfortran As noted above, mcp-work.for calculates the I \u2212 V characteristics of the simulated junction for several different values of\u03b1rf, producing one output file for each I\u2212V curve. The section of the code that defined the names of the output files was quite convoluted,\nil=0 DO alpha_rf=0.0, 50.0, 0.5 ...\nc ------ define output file name(s) il=il+1 il2=INT(il/100) il1=INT(il/10)-il2*10 il0=il-il1*10-il2*100 filewrite=\u2019PU\u2019//CHAR(il2+47)//CHAR(il1+47)//CHAR(il0+47)\n... END DO ! repeat alpha_rf DO cycle\nand used the integer variableil to count the cycle number, while the three integersil2, il1 andil0 contained thehundreds, tens andunits digits of il, respectively. TheCHAR function converts these integers to the corresponding ASCII characters, where ASCII code 48 corresponds to the 0 symbol and ASCII code 57 corresponds to 9. The name of the output file defined in the variable filewrite was built by concatenating a trailing constant string (\u2019PU\u2019 in the example above) to the three ASCII characters, using the double forward slash (//) operator.\nReScience C 6.1 (#10) \u2013 Maggi 2020 6\nI have no idea why I decided to build the name the output files in such a complex way, while it would have been much simpler to use the value of \u03b1rf. In any case, it did not work under gfortran and prevented proper compilation of the code. After some inspection it was apparent that the number 47 added to integer variables in the three CHAR function calls was the source of the error, and that it should be replaced by 48. The line defining the filewrite variable thus becomes,\n... DO alpha_rf=0.0, 50.0, 0.5 ...\nc ------ define output file name(s) ... filewrite=\u2019PU\u2019//CHAR(il2+48)//CHAR(il1+48)//CHAR(il0+48)\n... END DO ! repeat alpha_rf DO cycle\nWith this change mcp-work.for could compile flawlessly under gfortran. What is still puzzling is how the original line could work in Microsoft Fortran 5.1.\n5 Visual Basic code\nNo attempt was made to try to run the original Visual Basic 1.0 program on a modern computer. Visual Basic is a dead language and long since has been replaced by Visual Basic .NET, which shares only the name with its forefather. From the beginning, the only viable option to run a Visual Basic 1.0 application today was to rebuild the original development environment based on DOS 6.22 and Windows 3.11 in an emulator. The other possible alternative, try to setup an ancient PC still capa\u2010 ble to run DOS and Windows 3.11, albeit in principle interesting to ensure a replication of the original paper at the hardware level, would have posed more problems than it solved, adding little to the accuracy of the reproduction itself. I preferred to use the Parallels Desktop emulator for macOS, but popular alternatives such as VMwareWorkstation forWindows or the VirtualBox open sourcemulti\u2010platform emulator should work equally well. I created a new empty virtual machine with minimal hardware requirements and in\u2010 stalled in sequence DOS 6.22, Windows 3.11 and Visual Basic 1.0 (Fig. 2). While I was at it, and although I had already reproduced the Fortran part of the project, I also de\u2010 cided to install Microsoft Fortran 5.1 for DOS, to try to recreate as much as possible the original work environment. All software packages were downloaded from the WinWorld web site, an invaluable re\u2010 source for recovering old software packages. Even after somany years, the legitimacy of installing proprietary software in an emulator, might be questionable. But at the time I had regular licenses for all the above mentioned software and I guess to be at least morally authorized to continue to use those packages. Unfortunately, this also means that it is not possible to share the image of the virtual machine used to run the Visual Basic program on the paper\u2019s GitHub repository, since it contains proprietary software. Thepackageswere originally distributed on several floppydisks, whichhad to be swapped whenever the installer required a new disk. The installation of these software packages in an emulator is close to how it was done back then. The only difference is that to\u2010 day the floppy disks are replaced by virtual file images and swapping disks is not done mechanically but requires to select a menu option in the emulator. At the end of the installation process, the Windows 3.11 appeared as in Fig. 2. The de\u2010 fault 640\u00d7 480 pixel screen resolution of Windows 3.11 was woefully meager by today\u2019s standards but, as I used the virtual environment almost exclusively to run the Visual Basic program, I didn\u2019t bother to install the video drivers that could increase the screen resolution to a more comfortable 800\u00d7 600 or 1024\u00d7 768 pixel resolution.\nReScience C 6.1 (#10) \u2013 Maggi 2020 7\nUsing the emulator required to transfer the source and binary Visual Basic files to the emulated DOS/Windows system. It is surely possible to make the emulated Windows 3.11 communicate with the host operating system through the network. But I found much easier to use again a virtual floppy disk to transfer all needed files frommacOS to Windows 3.11 (and viceversa). A new empty virtual floppy disk data.img can be easily createdwith the command\u2010line utility dd available on macOS or Linux dd if=/dev/zero of=data.img bs=1440k count=1\nAfter creation, the virtual floppy disk must be mounted in the emulator and formatted under DOS or Windows 3.11 in the original MS\u2010DOS FAT file system. This step completed the preparation of the development environment, now it was time to test how all this behaved.\n6 Running the programs\nAs already noted, mcp-work.for calculates the I \u2212 V characteristics for a range of values of \u03b1rf, saving each curve in a separate output file. The lower and upper limits and the step size of \u03b1rf are hardcoded in the Fortran source code ad every change requires a recompilation of mcp-work.for (aminor hassle, as the compilation takes just a couple of seconds on a modern machine). Also thenames of the output datafiles arehard\u2010coded inmcp-work.for in thefilewrite variable and are conventionally composed by a two\u2010letter prefix (\u201cSI\u201d for the single drive, \u201cBI\u201d for the biharmonic drive and \u201cPU\u201d for the pulsed drive) followed by a three\u2010digit in\u2010 teger that represents the cycle number (Section 4.5). To avoid cluttering the mccumber/ directory that contains the Fortran source files with the output data files produced by the simulations, I created a new directory in the main project folder, 2020runs/, where I copied the mc-iv.dat configuration file needed to start the simulation (Fig. 1).\nReScience C 6.1 (#10) \u2013 Maggi 2020 8\nOn a recent (but not state\u2010of\u2010the art) machine the whole simulation with 100 \u03b1rf steps takes around 5minutes for the single drive and 7minutes for the pulsed drive, andmost of the time is spent printing on the terminal the calculated I\u2212V characteristics for each value of \u03b1rf. Such feedback was useful at the time of the original calculation, as every new calculated point of the I \u2212 V characteristics appeared on the screen after several tens of seconds, now the results scroll on the screen at a speed that makes them almost illegible. However, to keep as faithful as possible to the original project, I decided to continue to print the data points on the computer screen. The I\u2212V characteristics calculated with the sinusoidal drive are shown in Fig. 3 for dif\u2010 ferent values of \u03b1rf. Withoutmicrowave radiation (\u03b1rf = 0), the simulation produces the well\u2010known I \u2212 V characteristic of an overdamped Josephson junction (Fig. 3a), while for non\u2010zero values of \u03b1rf the staircase\u2010like structure of the rf\u2010induced current steps ap\u2010 pears on the I \u2212 V curves (Fig. 3b and Fig. 3c). For a pulsed drive, the I \u2212 V characteristic without microwave radiation is identical to that calculated with the sinusoidal signal (Fig. 4a), while for \u03b1rf > 0.0 the current steps induced by the pulsed drive are fewer than with the sinusoidal drive and can be nearly as wide as the critical current (compare Figs. 4a and 4c). At the end of each run, the output files should be transferred to theWindows 3.11 virtual machine to be processed by stepampl, the Visual Basic application described in Sec\u2010 tion 5. However Windows 3.11 does not understand Unix line terminators and cannot read the output files without a preliminary conversion. The conversion can be easily done in the macOS Terminal by issuing the following command, $ for f in $(ls *.out); do sed -i .bak s/$/$\u2019\\r\u2019/ $f ; done\nthat changes the line terminators of the .out output files from the Unix format contain\u2010 ing only a line\u2010feed (LF) to the carriage return followed by a line\u2010feed (CR\u2010LF) format\nReScience C 6.1 (#10) \u2013 Maggi 2020 9\nused by all versions of Microsoft Windows.5. The -i switch allows in\u2010place conversion of each file. The original files are kept adding a .bak extension. The output files in the proper Windows compatible format can now be transferred onto the virtual floppy disk image. When the transfer is done, the floppy disk image is un\u2010 mounted from the host operating system and mounted in the virtual machine, making it visible to Windows 3.11. The output files are copied to an empty directory of Win\u2010 dows 3.11 and the Visual Basic application is started, either by running the precompiled stepampl.exe executable or by opening the Visual Basic project and running the pro\u2010 gram from there (Fig. S5), saving the results in another text file with extension .STP (for steps) that could be transferred back to the host operating system via the virtual floppy disk image. I also briefly tried to run the original Fortran code using the Microsoft Fortran 5.1 in\u2010 stalled in the emulator. Compilation was fine but the resulting DOS program was ex\u2010 tremely slow, taking about 30 \u2212 35 seconds for each \u03b1rf cycle and about 60 minutes in total for the sinusoidal drive, more than a tenfold increase with respect to the native macOS version compiled with gfortran. Even considering the overhead of the emula\u2010 tor, the difference is too large not to be attributed to the low quality of the binary code generated by the Microsoft Fortran 5.1 compiler.\n7 Results\nAt the time of writing the original paper the whole process had to be repeated each night for a different set of input parameters and for a different kind of microwave signal (single, biharmonic or pulsed). Each night I used three of the available DEC workstations to simulate the junction be\u2010 havior with the pulsed drive, using three different values of the (normalized) width of the pulse signal, \u03c1, while keeping constant all the other parameters, such \u03b2 and \u2126. The only other difference in these simulation was the range of variation of \u03b1rf, which de\u2010 pended on the value of \u03c1 (shorter pulses require a much larger intensity of the rf\u2010signal to have the same effect on the junction). The fourth workstation simulated the junc\u2010 tion behavior with the standard sinusoidal drive, using exactly the same set of junction parameters. The original paper contained all the information needed to reproduce the results shown in the figures, without having to repeat thewhole analysis from scratch. The parameters used in all runs were: hysteresis parameter \u03b2 = 0.01, frequency of the sinusoidal or\n5Slightly different versions of the command can be found on the internet; the format used above is POSIX\u2010 compliant and should run on any Unix flavour\nReScience C 6.1 (#10) \u2013 Maggi 2020 10\npulsed rf signal \u2126 = 0.45, current bias between \u03b1dc = \u22125.0 and \u03b1dc = 5.0, integration time \u03c4 = 500, time step\u2206\u03c4 = 0.01. The simulation with the sinusoidal drive was performed by varying the amplitude of the microwave signal\u03b1rf between 0.0 and 5.0, with a step\u2206\u03b1rf = 0.05. The three simulations with the pulsed drive were done using: (1) pulse width \u03c1 = 0.250, \u03b1rf = 0.0 \u2212 10.0, \u2206\u03b1rf = 0.1; (2) pulse width \u03c1 = 0.125, \u03b1rf = 0.0 \u2212 20.0, \u2206\u03b1rf = 0.2; (3) pulse width \u03c1 = 0.050, \u03b1rf = 0.0\u2212 50.0,\u2206\u03b1rf = 0.5. The resulting output and summaryfileswere saved in separate folders in the2020runs/ directory, named SINGLE/, PULS0250/, PULS125/, PULS0050/ after their DOS coun\u2010 terparts. To reproduce the first and second figure of Ref. [14] Imade the only concession tomoder\u2010 nity. Instead of trying to recreate them with the plotting program used originally, prob\u2010 ably Origin 2.0, I decided to write a couple of small R scripts that could automate the task. The results are shown in Fig. 5 and Fig. 6 and, as expected, are identical to those reported in the first two figures of Ref. [14]. The large vertical steps on the rightmost curves of Fig. 5 era the first rf\u2010induced current steps, that can be nearly as large as the critical current IC without rf bias visible in the first I \u2212 V characteristic on the left. Figure 3 of the original paper could also be easily reproduced by plotting the maxima of the curves of Fig. 6, i.e.,\u2206in vs. \u03b1rf, for the four different cases considered here. Similar considerations canbemade for the reproduction of Figure 4 of the original paper, which considers a slightly hysteretic junctionwith \u03b2 = 1.0. For simplicity, I have chosen to show instead the \u2206in vs. \u03b1rf curves for the two most significant cases of microwave signal, i.e., the sinusoidal drive and the pulsed drive with \u03c1 = 0.050 (Fig. 7), from which the plots of Figure 4 could be easily replicated.\n8 Code availability\nAll code used for this replication is available in the project\u2019s GitHub repository. However, the term \u201dall\u201d should be taken with a grain of salt. While the Fortran is truly available to everyone and can be used as\u2010is by compiling it with gfortran or with any other compati\u2010 ble modern Fortran compiler, the Visual Basic 1.0 code poses a completely different set\nReScience C 6.1 (#10) \u2013 Maggi 2020 11\nReScience C 6.1 (#10) \u2013 Maggi 2020 12\nof problems. First of all, it can be run only by rebuilding an exact replica of the original develop\u2010 ment environment, as noted in Section 5. A task that without proper documentation can require a lot of trial\u2010and error, as the author of the present paper discovered during the course of this work, when he found that the original code could not be imported in any later versions of Visual Basic for Windows and even in Visual Basic 1.0 for MS\u2010DOS, released by Microsoft in parallel with the initial Windows version. Second, the source code of a Visual basic program is a mix of Basic source files (having the usual .bas extension) and of Forms objects that compose the graphical interface of the program (with extension .frm), stored in some binary format and tied together in a container, known as a Visual Basic project (extension .mak), as shown in Fig. S6). Making things worse, a Visual Basic project cannot be exported, the idea of code sharing or reuse across different applications was almost unknown at the time, at least in the commercial world. The obvious consequence is that the reproduction described here would fail to comply, at least in part, with one of the basic requirements of the Ten Years Challenge, i.e. the availability of all the source code used for the reproduction. But even if Visual Basic code seems locked for eternity in its proprietary binary format, there is a simple, albeit partial, solution to this problem, printing to a file. Printing was a true necessity back then to inspect or debug code. Computer screens were small and editors were primitive, the best way to have an overall view of a programduring develop\u2010 ment was to print it on paper. Visual Basic 1.0 is no exception and can easily print both the Basic source code and the layout of each form composing the graphical interface. Once realized that, it is easy to set up a PostScript Printer in Windows 3.11 and to print the Basic sources and the forms to two separate PostScript files on the Windows 3.11 virtual disk. Transfer of these files to macOS is done again using the virtual floppy disk image and, once in macOS, it is a questions of seconds to convert the PostScript files to themore popular PDF format using the Preview application available in every version of\nReScience C 6.1 (#10) \u2013 Maggi 2020 13\nmacOS. The finishing touch is to use an R script (already developed for another project) to extract the text from the PDF file containing the Basic code, saving it to a true text source file, so that it can be easily inspected by everyone interested in this project.\n9 Discussion\nThe main problem with this reproduction was the accidental loss of all my handwritten notes about the project, that compelled me to recover all information needed from the source and data files. Keeping good and updated documentation about any research project is paramount but equally important is to store all documentation in a safe loca\u2010 tion, where it can be easily retrieved. Today most documents are in electronic form, making them even more prone to data loss whenever a disaster strikes. Implementing a good and reliable backup strategy on different forms of storage media should be a mandatory requirement of any research project, and this strategy should always combine local backups with backups on sec\u2010 ondary storage locations, physically well separated from the original data source. Starting the project today from scratch I would make very different choices about the programming languages to use for the simulation and data analysis steps. Fortran, despite its venerable age, is still an excellent language for scientific program\u2010 ming, but today I would surely prefer Python, because of its flexibility, ease of use, and availability of excellent numerical libraries, such as NumPy and SciPy. The main problem with Python is related to the tumultuous development of the lan\u2010 guage itself and of the thousands of available modules, which can cause incompatibili\u2010 ties even with code developed a few years ago. This problem can be, at least temporarily, be solved by using virtual environments, but a better standardized solution is strongly needed. Another problem is related to its nature of interpreted language. However, the presence of well\u2010documented Fortran and C bindings, can enhance performance of time\u2010critical sections of code. Starting today I would also avoid using a new language, as was Visual Basic 1.0 at the time for a scientific project. It is true that in 1993\u201094 it would have been very hard to foresee the rapid demise of Microsoft\u2019s Visual Basic, nevertheless using a programming language only when its main core is stable, runs on a wide array of operating systems and is accepted by a wide community of developers is surely a safer bet. Not every software project can afford to be as stable as TEX, the scientific typesetting sys\u2010 tem invented by the prominentmathematician and computer scientist Donald E. Knuth, that has reached a state where \u201cit is unwise tomake further improvements to the system [..] which should give the same results 100 years from now that they produce today\u201d [21]. But on the other hand, a development environment that changes toomuch and too often or that is subjected to the whims of a single software company creates more problems than it solves.\n10 Conclusions\nGoing back to my old paper has been an exceptionally interesting and instructive expe\u2010 rience and I thank the organizers of this challenge for the opportunity offered. However this is not only a nostalgic attitude. The reproducibility crisis is a serious issue today [22], that undermines scientific credibility and impacts the public\u2019s trust in sci\u2010 ence, paving the way to all sorts of fake and unscientific beliefs. Being able to go back and reproduce what has been done in the past could ease the retraction of published papers containing fabricated, falsified, or modified data or results and could contribute to simplify the identification of future frauds.\nReScience C 6.1 (#10) \u2013 Maggi 2020 14\nThis of course requires to share andmake freely available the original data and the tools used to analyze them. A few years ago this requirement was impossible to fulfill in practice. The digital world in which we live makes it almost inevitable."}], "title": "[Rp] Reproduction of Step width enhancement in a pulse-driven Josephson junction", "year": 2020}